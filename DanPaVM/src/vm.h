#ifndef VM_H_INCLUDED
#define VM_H_INCLUDED

// if compiler supports label-as-values and statement expressions
#if ((defined(__GNUC__) && __GNUC__ >= 3) || defined(__clang__))
#define USE_COMPUTED_GOTOS
#endif

#include <stdint.h>
#include <stdlib.h>


// 2^16 is the global maximum for these values
#define STACK_DEPTH 65536
#define MAX_CALL_DEPTH 16
#define VAR_COUNT 65536
#define MAX_MEMORY_REGIONS 65536
#define LVAR_PAGES MAX_CALL_DEPTH
#define FEQ_EPSILON 0.0001f

typedef uint64_t var_t;

typedef struct memory_region_t
{
    var_t* base;
    uint32_t size;
} memory_region_t;

typedef enum var_type
{
    INVALID = 0,
    INT = 1,
    FLOAT = 2,
    NULLVAL = 3,
    LVAR_PTR = 4,
    GVAR_PTR = 5,
    PTR = 6,
    STR = 7
} var_type;

// used for type-punning
union int_float
{
    uint32_t i;
    float f;
};

#define MK_VAR_TYPE(type) ((uint64_t)(type) << 48)
#define MK_VAR_OBJ(obj) ((uint64_t)(obj) << 32)
#define MK_VAR(val, type) ((uint32_t)(val) | (uint64_t)MK_VAR_TYPE(type))
#define MK_FLT(val) ((uint32_t)((union int_float*)&val)->i | (uint64_t)MK_VAR_TYPE(FLOAT))
#define MK_PTR(obj) ((uint32_t)0 | (uint64_t)MK_VAR_OBJ(obj) | (uint64_t)MK_VAR_TYPE(PTR))
#define MK_STR(obj) ((uint32_t)0 | (uint64_t)MK_VAR_OBJ(obj) | (uint64_t)MK_VAR_TYPE(STR))
#define VAR_TYPE(var) (uint16_t)(var >> 48)
#define VAR_VAL(var) (uint32_t)(var&0xFFFFFFFF)
#define VAR_VAL_FLT(var) ((union int_float*)&var)->f
#define VAR_SET_VAL(var, val) do { uint64_t vsv_loc = val; var &= 0xFFFFFFFF00000000LL; var |= (vsv_loc&0xFFFFFFFFLL); } while (0)
#define VAR_OFFSET(var) (uint32_t)(var&0xFFFFFFFF)
#define VAR_OBJECT(var) ((var >> 32)&0xFFFF)
#define OBJ_MEM(obj, offset) vm->mem_regions[obj].base[offset]

#define BOOL_TEST(var) (VAR_VAL(var) != 0)


_Static_assert (sizeof(float) == sizeof(uint32_t), "Invalid float type size");
/*
typedef struct var_t
{
    union
    {
        uint32_t i32;
        float    f32;
        uint32_t offset;   // offset into the object's memory region
    };
    uint16_t object; // memory region id if type is PTR or STR
    uint16_t type;
} var_t;
_Static_assert (sizeof(var_t) == sizeof(uint64_t), "var_t is supposed to be 64-bit wide");
*/

typedef struct string_entry_t
{
    uint16_t str_len;
    char* str;
} string_entry_t;

typedef struct vm_state_t vm_state_t;
typedef void(*syscall_callback)(vm_state_t*);
typedef struct vm_state_t
{
    uint32_t pc;
    uint16_t sp;
    uint32_t init_addr;
    uint32_t main_addr;
    int stopped;
    uint32_t rand_seed;

    uint8_t* exec_buffer;
    string_entry_t* string_table;
    uint16_t string_table_size;
    unsigned next_likely_free_region;
    int      call_depth;

    var_t data_stack[STACK_DEPTH];
#ifndef USE_COMPUTED_GOTOS
    uint32_t call_stack[MAX_CALL_DEPTH];
#else
    uint8_t* call_stack[MAX_CALL_DEPTH]; // store direct pointers into memory
#endif
    var_t loc_var_pages[LVAR_PAGES][VAR_COUNT];

    var_t glob_vars[VAR_COUNT];

    syscall_callback syscalls[256];

    uint32_t allocated_region_count;
    memory_region_t mem_regions[MAX_MEMORY_REGIONS];
} vm_state_t;

// runs until vm->stopped is true
void vm_run(vm_state_t* vm);
// run the GC; returns the number of memory regions freed
int vm_run_gc(vm_state_t* vm);

#define VM_RAND_MAX 4294967295LL
// returns a random number generated by this vm instance's seed
uint32_t vm_rand(vm_state_t* vm);

// returns the index of a newly allocated memory region
uint16_t alloc_memory_region (vm_state_t* vm, uint32_t size);
// resizes an existing memory region
void     resize_memory_region(vm_state_t* vm, uint16_t region_id, uint32_t size);
// frees an existing memory region
void     free_memory_region(vm_state_t* vm, uint16_t region_id);

static inline var_t pop_stack(vm_state_t* vm)
{

    var_t val = vm->data_stack[vm->sp];
    ++vm->sp;
    /*
    if (__builtin_expect(vm->sp == STACK_DEPTH-1, 0)) // covers the case of underflow
    {
        abort();
        __builtin_unreachable();
    }*/

    return val;
}

static inline void push_stack(vm_state_t* vm, var_t value)
{
    /*
    if (__builtin_expect(vm->sp == STACK_DEPTH-1, 0)) // covers the case of underflow
    {
        abort();
        __builtin_unreachable();
    }
    */
    --vm->sp;
    vm->data_stack[vm->sp] = value;

}

static inline var_t vm_load(vm_state_t* vm, var_t ptr)
{
    var_t result;
    if (VAR_TYPE(ptr) == PTR || VAR_TYPE(ptr) == STR)
        result = vm->mem_regions[VAR_OBJECT(ptr)].base[VAR_OFFSET(ptr)];
    else if (VAR_TYPE(ptr) == LVAR_PTR)
        result = vm->loc_var_pages[VAR_OBJECT(ptr)][VAR_OFFSET(ptr)];
    else // if (VAR_TYPE(ptr) == GVAR_PTR)
        result = vm->glob_vars[VAR_OFFSET(ptr)];

    return result;
}

static inline void vm_store(vm_state_t* vm, var_t ptr, var_t val)
{
    if (VAR_TYPE(ptr) == PTR)
        vm->mem_regions[VAR_OBJECT(ptr)].base[VAR_OFFSET(ptr)] = val;
    else if (VAR_TYPE(ptr) == LVAR_PTR)
        vm->loc_var_pages[VAR_OBJECT(ptr)][VAR_OFFSET(ptr)] = val;
    else // if (VAR_TYPE(ptr) == GVAR_PTR)
        vm->glob_vars[VAR_OFFSET(ptr)] = val;
}

// allocates and create a vm instance for a script
vm_state_t* create_vm(const char* script_path);
// run the globals initialization code
void vm_run_init(vm_state_t* vm);
// resets the vm execution state
void vm_reset(vm_state_t* vm);
// clears the vm memory data
void vm_clear(vm_state_t* vm);
// cleans up a vm
void cleanup_vm(vm_state_t* vm);
// converts a vm STR to a c-style string
void vm_read_str(vm_state_t* vm, var_t str, char *buf, unsigned buf_size);

int register_syscall(vm_state_t* vm, uint8_t number, syscall_callback syscall);

#endif // VM_H_INCLUDED
